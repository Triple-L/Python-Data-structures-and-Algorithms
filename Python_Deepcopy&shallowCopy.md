非常好的python学习资料：
https://my.oschina.net/leejun2005?tab=newest&catalogId=219093  

Python中对于新元素的创建，没有建立列表/分配内存。例如创建values = [1,2,3]
在内存中单独开辟内存给 [1,2,3] 然后令 values指向该列表，跟Java类似。（垃圾回收？）
Python 没有赋值，只有引用。Python 做的事情是首先创建一个列表对象 [0, 1, 2]，然后给它贴上名为 values 的标签。如果随后又执行values = [3, 4, 5]的话，Python 做的事情是创建另一个列表对象 [3, 4, 5]，然后把刚才那张名为 values 的标签从前面的 [0, 1, 2] 对象上撕下来，重新贴到 [3, 4, 5] 这个对象上。
至始至终，并没有一个叫做 values 的列表对象容器存在，Python 也没有把任何对象的值复制进 values 去。过程如图所示：

执行values[1] = values的时候，Python 做的事情则是把 values 这个标签所引用的列表对象的第二个元素指向 values 所引用的列表对象本身。执行完毕后，values 标签还是指向原来那个对象，只不过那个对象的结构发生了变化，从之前的列表 [0, 1, 2] 变成了 [0, ?, 2]，而这个 ? 则是指向那个对象本身的一个引用。如图所示：

要达到你所需要的效果，即得到 [0, [0, 1, 2], 2] 这个对象，你不能直接将 values[1] 指向 values 引用的对象本身，而是需要吧 [0, 1, 2] 这个对象「复制」一遍，得到一个新对象，再将 values[1] 指向这个复制后的对象。Python 里面复制对象的操作因对象类型而异，复制列表 values 的操作是
values[:] #生成对象的拷贝或者是复制序列，不再是引用和共享变量，但此法只能顶层复制
所以你需要执行
values[1] = values[:]
values[:] 复制操作是所谓的「浅复制」(shallow copy)，当列表对象有嵌套的时候也会产生出乎意料的错误：
a = [0, [1, 2], 3] b = a[:] a[0] = 8 a[1][1] = 9

深复制
import copy 
a = [0, [1, 2], 3]
 b = copy.deepcopy(a) 
a[0] = 8 a[1][1] = 9



so 深浅复制的区别就在于，浅复制只复制第一层，list之中嵌套的其他指针不会被重新分配内存。深复制完全开辟一个同样内容的自己的东西。
